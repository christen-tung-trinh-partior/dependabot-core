/* Vulnerability auditor for npm
 *
 * Inputs:
 *  - path to directory containing a package.json and a package-lock.json
 *  - array of security advisories to audit for,
 *      [
 *        { dependency_name: string, affected_versions: [string, ...] },
 *        ...
 *      ]
 *
 * Outputs:
 *  - object indicating whether a fix is available and how to achieve it,
 *      {
 *        dependency_name: string,
 *        current_version: string,
 *        target_version: string,
 *        fix_available: boolean | object,
 *        fix_updates: [
 *          {
 *            dependency_name: string,
 *            current_version: string,
 *            target_version: string
 *          },
 *          ...
 *        ]
 *      }
 */

const Arborist = require('@npmcli/arborist')
const nock = require('nock')
const { promisify } = require('util');
const exec = promisify(require('child_process').exec)

async function findVulnerableDependencies(directory, advisories) {
  const npmConfig = await loadNpmConfig()
  const caCerts = loadCACerts(npmConfig)
  const registryOpts = extractRegistryOptions(npmConfig)

  const arb = new Arborist({
    path: directory,
    auditRegistry: 'http://localhost:9999',
    ca: caCerts,
    force: true,
    dryRun: true,
    ...registryOpts,
  })

  const scope = nock('http://localhost:9999')
    .persist()
    .post('/-/npm/v1/security/advisories/bulk')
    .reply(200, convertAdvisoriesToRegistryBulkFormat(advisories))

  if (!nock.isActive()) {
    nock.activate()
  }

  try {
    const name = advisories[0].dependency_name
    const auditReport = await arb.audit()
    const vuln = auditReport.get(name)
    const version = [...vuln.nodes][0].version
    const fixAvailable = vuln.fixAvailable
    const response = {
      dependency_name: name,
      current_version: version,
      fix_available: Boolean(fixAvailable),
      fix_updates: [],
    }

    if (!Boolean(fixAvailable)) {
      return response
    }

    const chains = buildDependencyChains(auditReport, name)

    // In order to consider the vuln dependency in question fixable,
    // all dependency chains originating from it must be fixable.
    if (chains.some((chain) => !Boolean(chain.fixAvailable))) {
      response.fix_available = false
      return response
    }

    for (const chain of chains) {
      const topMost = chain.items[0]
      if (topMost.name === name) {
        continue
      }
      response.fix_updates.push({
        dependency_name: topMost.name,
        current_version: topMost.version,
      })
    }

    const fixTree = await arb.audit({
      fix: true,
    })

    response.target_version = fixTree.children.get(name)?.version

    for (const update of response.fix_updates) {
      update.target_version =
        fixTree.children.get(update.dependency_name)?.version
    }

    return response
  } finally {
    nock.cleanAll()
    nock.restore()
  }
}

function convertAdvisoriesToRegistryBulkFormat(advisories) {
  // npm audit differentiates advisories by `id`. In order to prevent
  // advisories from being clobbered, we maintain a counter so that each
  // advisory gets a unique `id`.
  let nextAdvisoryId = 1

  return advisories.reduce((formattedAdvisories, advisory) => {
    if (!formattedAdvisories[advisory.dependency_name]) {
      formattedAdvisories[advisory.dependency_name] = []
    }
    let formattedVersions =
      advisory.affected_versions.reduce((memo, version) => {
        memo.push({
          id: nextAdvisoryId++,
          vulnerable_versions: version
        })
        return memo
      }, [])
    formattedAdvisories[advisory.dependency_name].push(...formattedVersions)
    return formattedAdvisories
  }, {})
}

/* Traverses all effects originating from the named dependency in the
 * audit report and builds an array of all dependency chains,
 *   [
 *    {
 *      fixAvailable: true | false | object,
 *      items: [
 *        { name: 'foo', version: '1.0.0' },
 *        ...
 *      ]
 *    },
 *    ...
 *   ]
 *
 * The first item in the chain is always the top-most dependency affected by
 * the vulnerable dependency in question. The `fixAvailable` field
 * applies to the first item in the chain (if that item is fixable, then
 * every item after it must be fixable, too).
 */
function buildDependencyChains(auditReport, name, chain = { items: [] }) {
  const vuln = auditReport.get(name)
  const version = [...vuln.nodes][0].version
  const item = { name, version }

  if (!vuln.effects.size) {
    // If the current vuln has no effects, we've reached the end of this chain.
    return [{ fixAvailable: vuln.fixAvailable, items: [item, ...chain.items] }]
  }

  return [...vuln.effects].reduce((chains, effect) => {
    return chains.concat(
      buildDependencyChains(
        auditReport, effect.name, { items: [item, ...chain.items] }))
  }, [])
}

async function loadNpmConfig() {
  const configOutput = await exec('npm config ls --json')
  return JSON.parse(configOutput.stdout)
}

function extractRegistryOptions(npmConfig) {
  const opts = []
  for (const [key, value] of Object.entries(npmConfig)) {
    if (key == "registry" || key.endsWith(":registry")) {
      opts.push([key, value])
    }
  }
  return Object.fromEntries(opts)
}

// sourced from npm's cli/lib/utils/config/definitions.js for reading certs from the cafile option
const fs = require('fs')
const maybeReadFile = file => {
  try {
    return fs.readFileSync(file, 'utf8')
  } catch (er) {
    if (er.code !== 'ENOENT') {
      throw er
    }
    return null
  }
}

function loadCACerts(npmConfig) {
    if (npmConfig.ca) {
      return npmConfig.ca
    }

    if (!npmConfig.cafile) {
      return
    }

    const raw = maybeReadFile(npmConfig.cafile)
    if (!raw) {
      return
    }

    const delim = '-----END CERTIFICATE-----'
    return raw.replace(/\r\n/g, '\n').split(delim)
      .filter(section => section.trim())
      .map(section => section.trimStart() + delim)
}

module.exports = { findVulnerableDependencies }
