/* Vulnerability auditor for npm
 *
 * Inputs:
 *  - directory containing a package.json and a package-lock.json
 *  - security advisories to audit for,
 *      [{"dependency_name": string, "affected_versions": [string]}]
 *
 * Outputs:
 *  - A report of vulnerable dependencies
 */

const Arborist = require("@npmcli/arborist");
const nock = require('nock')

// TODO: we observed when we passed several vuln ranges to the bulk endpoint,
// one range that was below installed version and two above it, the response
// indicated no vulns. Why? Do we need to filter out vuln ranges that don't
// include the installed version before passing them to this function?
async function findVulnerableDependencies(directory, advisoriesStr) {
  const advisories = JSON.parse(advisoriesStr)
  const arb = new Arborist({
    path: directory,
    auditRegistry: 'http://localhost:9999'
  });

  const scope = nock('http://localhost:9999')
    .persist()
    .post("/-/npm/v1/security/advisories/bulk")
    .reply(200, convertAdvisoriesToRegistryBulkFormat(advisories))

  if (!nock.isActive()) {
    nock.activate()
  }

  const name = advisories[0].dependency_name

  try {
    const report = await arb.audit()
    const vuln = report.get(name)
    const fixAvailable = vuln.fixAvailable
    const response = {
      dependency_name: vuln.name,
      current_version: [...vuln.nodes][0].version,
      fix_available: (fixAvailable !== false),
      fix_updates: [],
    }

    if (!response.fix_available) {
      return response
    }

    let highest = vuln

    while (highest.effects.size) {
      highest = [...highest.effects][0]
    }

    if (highest !== vuln) {
      if (report.get(highest.name).fixAvailable === false) {
        response.fix_available = false
        return response
      }

      response.fix_updates.push({
        dependency_name: highest.name,
        current_version: [...highest.nodes][0].version
      })
    }

    const fixTree = await arb.audit({
      fix: true,
      // If fixAvailable is an object, e.g., { name, version, isSemVerMajor }
      // that means we need to audit with --force.
      force: (typeof fixAvailable === 'object'),
    })

    response.target_version =
      fixTree.children.get(response.dependency_name)?.version

    for (const update of response.fix_updates) {
      update.target_version =
        fixTree.children.get(update.dependency_name)?.version
    }

    return response
  } finally {
    // TODO: is this correct cleanup?
    nock.cleanAll()
    nock.restore()
  }
}

function convertAdvisoriesToRegistryBulkFormat(advisories) {
  return advisories.reduce((formattedAdvisories, advisory) => {
    if (!formattedAdvisories[advisory.dependency_name]) {
      formattedAdvisories[advisory.dependency_name] = []
    }
    let formattedVersions =
      advisory.affected_versions.reduce((memo, version) => {
        memo.push({ vulnerable_versions: version })
        return memo
      }, [])
    formattedAdvisories[advisory.dependency_name].push(...formattedVersions)
    return formattedAdvisories
  }, {})
}

module.exports = { findVulnerableDependencies };
