/* Vulnerability auditor for npm
 *
 * Inputs:
 *  - path to directory containing a package.json and a package-lock.json
 *  - array of security advisories to audit for,
 *      [
 *        { "dependency_name": string, "affected_versions": [string, ...] },
 *        ...
 *      ]
 *
 * Outputs:
 *  - object indicating whether a fix is available and how to achieve it,
 *      {
 *        dependency_name: string,
 *        current_version: string,
 *       ?target_version: string,
 *        fix_vailable: boolean | object,
 *        fix_updates: [
 *          {
 *            dependency_name: string,
 *            current_version: string,
 *            target_version: string
 *          },
 *          ...
 *        ]
 *      }
 */

const Arborist = require("@npmcli/arborist")
const nock = require('nock')

async function findVulnerableDependencies(directory, advisories) {
  const arb = new Arborist({
    path: directory,
    auditRegistry: 'http://localhost:9999',
    force: true,
  })

  const scope = nock('http://localhost:9999')
    .persist()
    .post("/-/npm/v1/security/advisories/bulk")
    .reply(200, convertAdvisoriesToRegistryBulkFormat(advisories))

  if (!nock.isActive()) {
    nock.activate()
  }

  const name = advisories[0].dependency_name

  try {
    const report = await arb.audit()
    const vuln = report.get(name)
    const fixAvailable = vuln.fixAvailable
    const response = {
      dependency_name: vuln.name,
      current_version: [...vuln.nodes][0].version,
      fix_available: (fixAvailable !== false),
      fix_updates: [],
    }

    if (!response.fix_available) {
      return response
    }

    let highest = vuln

    while (highest.effects.size) {
      highest = [...highest.effects][0]
    }

    if (highest !== vuln) {
      if (report.get(highest.name).fixAvailable === false) {
        response.fix_available = false
        return response
      }

      response.fix_updates.push({
        dependency_name: highest.name,
        current_version: [...highest.nodes][0].version
      })
    }

    const fixTree = await arb.audit({
      fix: true,
    })

    response.target_version =
      fixTree.children.get(response.dependency_name)?.version

    for (const update of response.fix_updates) {
      update.target_version =
        fixTree.children.get(update.dependency_name)?.version
    }

    return response
  } finally {
    nock.cleanAll()
    nock.restore()
  }
}

function convertAdvisoriesToRegistryBulkFormat(advisories) {
  // npm audit differentiates advisories by `id`. In order to prevent
  // advisories from being clobbered, we maintain a counter so that each
  // advisory gets a unique `id`.
  let nextAdvisoryId = 1

  return advisories.reduce((formattedAdvisories, advisory) => {
    if (!formattedAdvisories[advisory.dependency_name]) {
      formattedAdvisories[advisory.dependency_name] = []
    }
    let formattedVersions =
      advisory.affected_versions.reduce((memo, version) => {
        memo.push({
          id: nextAdvisoryId++,
          vulnerable_versions: version
        })
        return memo
      }, [])
    formattedAdvisories[advisory.dependency_name].push(...formattedVersions)
    return formattedAdvisories
  }, {})
}

module.exports = { findVulnerableDependencies }
